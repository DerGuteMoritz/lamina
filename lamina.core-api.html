<html>
  <head>
    <title>lamina.core API reference (lamina)</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <!-- TODO: are we using these (from clojure.org)? If so, add the files -->
    <script src="file/view/code_highlighter.js" type="text/javascript"></script>
    <script src="file/view/clojure.js" type="text/javascript"></script>
    <style>.menuWrapper{height: 36px;}</style>
    <!--[if lte IE 6]>
    <link rel="stylesheet" href="http://www.wikispaces.com/_/2009051601/s/internal_ie.css" type="text/css" />
    <![endif]-->
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">lamina</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <a class="wiki_link" href="index.html">Overview</a><br />
    <a class="wiki_link" href="api-index.html">API Index</a><br />
    <a class="wiki_link" href="#">Namespaces:</a>
    <ul id="left-sidebar-list">
      <li><a href="lamina.connections-api.html" class="wiki_link">lamina.connections</a></li><li><a href="lamina.core-api.html" class="wiki_link">lamina.core</a></li>
    </ul>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0">Overview</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/afn">afn</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/async">async</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/blocking">blocking</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/cancel-callback">cancel-callback</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/channel-pair">channel-pair</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/channel-seq">channel-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/close">close</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/closed?">closed?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/complete">complete</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/do*">do*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/enqueue">enqueue</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/enqueue-and-close">enqueue-and-close</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/filter*">filter*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/fork">fork</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/future*">future*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/lazy-channel-seq">lazy-channel-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/map*">map*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/named-channel">named-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/on-closed">on-closed</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/on-sealed">on-sealed</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/pipeline">pipeline</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/poll">poll</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/read-channel">read-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/read-merge">read-merge</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/receive">receive</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/receive-in-order">receive-in-order</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/redirect">redirect</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/reduce*">reduce*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/reductions*">reductions*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/release-named-channel">release-named-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/restart">restart</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/run-pipeline">run-pipeline</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/sealed-channel">sealed-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/sealed?">sealed?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/siphon-result">siphon-result</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/splice">splice</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/take*">take*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/take-while*">take-while*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait">wait</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait-for-message">wait-for-message</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait-for-result">wait-for-result</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#lamina.core.fn">lamina.core.fn</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core.fn/async">async</a>
    </div>
    <br />
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="namespace-name">lamina.core</span></h1>
by <span id="author">Zachary Tellman</span><br />
<br />Usage:
<pre>
(ns your-namespace
  (:require <span id="long-name">lamina.core</span>))
</pre><pre>
</pre><h2>Overview</h2>
<pre id="namespace-docstr"></pre>
<br />
<h2>Public Variables and Functions</h2>
<div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/afn">afn</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (afn &amp; fn-args)
</pre>
  <pre id="var-docstr">An asynchronous variation on 'fn'.  See 'async' for more details.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/async">async</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (async f)
</pre>
  <pre id="var-docstr">Given a function, returns an asynchronous variant of that function.

An asynchronous function returns a result-channel instead of a value.  If any
parameters that it is passed are result-channels, it will delay execution until
all result channels have emitted a value.

If any of the input result-channels emit errors, the function will not execute
and simply emit the input error.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/blocking">blocking</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (blocking f)
</pre>
  <pre id="var-docstr">Takes a synchronous function, and returns a function which will be executed asynchronously,
and whose invocation will return a pipeline channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/cancel-callback">cancel-callback</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (cancel-callback ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Cancels one or more callbacks.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/channel-pair">channel-pair</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (channel-pair)
       (channel-pair a b)
</pre>
  <pre id="var-docstr">Creates paired channels, where an enqueued message from one channel
can be received from the other.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/channel-seq">channel-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (channel-seq ch)
       (channel-seq ch timeout)
</pre>
  <pre id="var-docstr">Creates a non-lazy sequence which consumes all messages from the channel within the next
'timeout' milliseconds.  A timeout of 0, which is the default, will only consume messages
currently within the channel.

This call is synchronous, and will hang the thread until the timeout is reached or the channel
is closed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/close">close</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (close ch)
</pre>
  <pre id="var-docstr">Closes the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/closed?">closed?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (closed? ch)
</pre>
  <pre id="var-docstr">Returns true if no more messages can be received from the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/complete">complete</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (complete result)
</pre>
  <pre id="var-docstr">Skips to the end of the inner-most pipeline, causing it to emit 'result'.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/do*">do*</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (do* &amp; body)
</pre>
  <pre id="var-docstr">Creates a pipeline stage that emits the same value it receives, but performs some side-effect
in between.  Useful for debug prints and logging.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/enqueue">enqueue</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (enqueue ch &amp; messages)
</pre>
  <pre id="var-docstr">Enqueues messages into the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/enqueue-and-close">enqueue-and-close</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (enqueue-and-close ch &amp; messages)
</pre>
  <pre id="var-docstr">Enqueues the final messages into the channel, sealing it.  When this message is
received, the channel will be closed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/filter*">filter*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (filter* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume all messages from 'ch', but only emit messages
for which (f msg) is true.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/fork">fork</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (fork ch)
       (fork n ch)
</pre>
  <pre id="var-docstr">Creates one or many exact copies of 'ch'.  Messages enqueued into the original channel
will appear in all copies, but can be consumed separately.  This allows for multiple
consumers to receive the same stream at different rates.

Any message enqueued into one channel will be enqueued into all other copies.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/future*">future*</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (future* &amp; body)
</pre>
  <pre id="var-docstr">A variation of 'future' that returns a result-channel instead of a synchronous
future object.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/lazy-channel-seq">lazy-channel-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (lazy-channel-seq ch)
       (lazy-channel-seq ch timeout)
</pre>
  <pre id="var-docstr">Creates a lazy-seq which consumes messages from the channel.  Only elements
which are realized will be consumes.

(take 1 (lazy-channel-seq ch)) will only take a single message from the channel,
and no more.  If there are no messages in the channel, execution will halt until
a message is enqueued.

'timeout' controls how long (in ms) the sequence will wait for each element.  If
the timeout is exceeded or the channel is closed, the sequence will end.  By default,
the sequence will never time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/map*">map*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (map* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume all messages from 'ch', and emit (f msg).</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/named-channel">named-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (named-channel key)
       (named-channel key creation-callback)
</pre>
  <pre id="var-docstr">Returns a unique channel for the key.  If no such channel exists,
a channel is created, and 'creation-callback' is invoked.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/on-closed">on-closed</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (on-closed ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Registers callbacks that will be triggered by the channel closing.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/on-sealed">on-sealed</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (on-sealed ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Registers callbacks that will be triggered by the channel being sealed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/pipeline">pipeline</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (pipeline &amp; opts+stages)
</pre>
  <pre id="var-docstr">Returns a function with an arity of one.  Invoking the function will return
a pipeline channel.

Stages should either be pipelines, or functions with an arity of one.  These functions
should either return a pipeline channel, a redirect signal, or a value which will be passed
into the next stage.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/poll">poll</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (poll channel-map)
       (poll channel-map timeout)
</pre>
  <pre id="var-docstr">Allows you to consume exactly one message from multiple channels.

If the function is called with (poll {:a a, :b b}), and channel 'a' is
the first to emit a message, the function will return a constant channel
which emits [:a message].

If the poll times out, the constant channel will emit 'nil'.  If a timeout
is not specified, the poll will never time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/read-channel">read-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (read-channel ch)
       (read-channel ch timeout)
</pre>
  <pre id="var-docstr">For reading channels within pipelines.  Takes a simple channel, and returns
a result channel representing the next message from the channel.  If the timeout
elapses, the result channel will emit an error.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/read-merge">read-merge</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (read-merge read-fn merge-fn)
</pre>
  <pre id="var-docstr">For merging asynchronous reads into a pipeline.

'read-fn' is a function that takes no parameters and returns a value, which
can be a pipeline channel representing an asynchronous read.

'merge-fn' is a function which takes two parameters - the incoming value from
the pipeline and the value from read-fn - and returns a single value that
will propagate forward into the pipeline.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/receive">receive</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (receive ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Adds one or more callbacks which will receive the next message from the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/receive-in-order">receive-in-order</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (receive-in-order ch f)
</pre>
  <pre id="var-docstr">Consumes messages from a channel one at a time.  The callback will only receive the next
message once it has completed processing the previous one.  If the callback returns a result
channel, the next message will not be received until there is a result.

This is a lossy iteration over the channel.  Fork the channel if there is another consumer.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/redirect">redirect</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (redirect pipeline)
       (redirect pipeline value)
</pre>
  <pre id="var-docstr">Returns a redirect signal, which if returned by a pipeline stage will
skip all remaining stages in the current pipeline, and begin executing
the stages in 'pipeline'.  'value' describes the initial value passed into
the new pipeline, and defaults to the initial value passed into the current
pipeline.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/reduce*">reduce*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (reduce* f ch)
       (reduce* f val ch)
</pre>
  <pre id="var-docstr">Returns a constant-channel which will return the result of the reduce once the channel has been exhausted.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/reductions*">reductions*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (reductions* f ch)
       (reductions* f val ch)
</pre>
  <pre id="var-docstr">Returns a channel which contains the intermediate results of the reduce operation.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/release-named-channel">release-named-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (release-named-channel key)
</pre>
  <pre id="var-docstr">Forgets the channel associated with the key, if one exists.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/restart">restart</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (restart)
       (restart value)
</pre>
  <pre id="var-docstr">A special form of redirect, which simply restarts the current pipeline.  'value'
describe sthe initial value passed into the first stage of the current pipeline,
and defaults to the value that was previously passed into the first stage.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/run-pipeline">run-pipeline</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (run-pipeline initial-value &amp; opts+stages)
</pre>
  <pre id="var-docstr">Equivalent to ((pipeline opts+stages) initial-value).

Returns a pipeline future.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/sealed-channel">sealed-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sealed-channel &amp; messages)
</pre>
  <pre id="var-docstr">Creates a channel which is already sealed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/sealed?">sealed?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sealed? ch)
</pre>
  <pre id="var-docstr">Returns true if no more messages can be enqueued into the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/siphon-result">siphon-result</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (siphon-result src dst)
</pre>
  <pre id="var-docstr">Siphons the result from one result-channel to another.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/splice">splice</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (splice src dst)
</pre>
  <pre id="var-docstr">Splices together a message source and a message destination
into a single channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/take*">take*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (take* n ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume 'n' messages from 'ch'.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/take-while*">take-while*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (take-while* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume messages from 'ch' until (f msg) is false.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait">wait</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (wait interval)
</pre>
  <pre id="var-docstr">Creates a pipeline stage that accepts a value, and emits the same value after 'interval' milliseconds.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait-for-message">wait-for-message</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wait-for-message ch)
       (wait-for-message ch timeout)
</pre>
  <pre id="var-docstr">Synchronously consumes a single message from a channel.  If no message is received within the
timeout, a java.util.concurrent.TimeoutException is thrown.  By default, this function will
not time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait-for-result">wait-for-result</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wait-for-result result-channel)
       (wait-for-result result-channel timeout)
</pre>
  <pre id="var-docstr">Waits for a result-channel to emit a result.  If it succeeds, returns the result.
If there was an error, the exception is re-thrown.

If the timeout elapses, a java.util.concurrent.TimeoutException is thrown.</pre>
  
</div>
<h2 id="namespace-name">lamina.core.fn</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="lamina.core.fn/async">async</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (async f)
</pre>
  <pre id="var-docstr">Given a function, returns an asynchronous variant of that function.

An asynchronous function returns a result-channel instead of a value.  If any
parameters that it is passed are result-channels, it will delay execution until
all result channels have emitted a value.

If any of the input result-channels emit errors, the function will not execute
and simply emit the input error.</pre>
  
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">No copyright info </div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>