<html>
  <head>
    <title>lamina.core API reference (lamina)</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <!-- TODO: are we using these (from clojure.org)? If so, add the files -->
    <script src="file/view/code_highlighter.js" type="text/javascript"></script>
    <script src="file/view/clojure.js" type="text/javascript"></script>
    <style>.menuWrapper{height: 36px;}</style>
    <!--[if lte IE 6]>
    <link rel="stylesheet" href="http://www.wikispaces.com/_/2009051601/s/internal_ie.css" type="text/css" />
    <![endif]-->
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">lamina</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <a class="wiki_link" href="index.html">Overview</a><br />
    <a class="wiki_link" href="api-index.html">API Index</a><br />
    <a class="wiki_link" href="#">Namespaces:</a>
    <ul id="left-sidebar-list">
      <li><a href="lamina.api-api.html" class="wiki_link">lamina.api</a></li><li><a href="lamina.connections-api.html" class="wiki_link">lamina.connections</a></li><li><a href="lamina.core-api.html" class="wiki_link">lamina.core</a></li><li><a href="lamina.executors-api.html" class="wiki_link">lamina.executors</a></li><li><a href="lamina.trace-api.html" class="wiki_link">lamina.trace</a></li>
    </ul>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0">Overview</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/async">async</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/cancel-callback">cancel-callback</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/channel-pair">channel-pair</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/channel-seq">channel-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/close">close</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/closed-channel">closed-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/closed?">closed?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/complete">complete</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/defn-async">defn-async</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/do-stage">do-stage</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/drained?">drained?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/enqueue">enqueue</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/enqueue-and-close">enqueue-and-close</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/filter*">filter*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/force-all">force-all</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/fork">fork</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/lazy-channel-seq">lazy-channel-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/map*">map*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/named-channel">named-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/on-closed">on-closed</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/on-drained">on-drained</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/partition*">partition*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/partition-all*">partition-all*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/pipeline">pipeline</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/poll">poll</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/read-channel">read-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/read-merge">read-merge</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/receive">receive</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/receive-in-order">receive-in-order</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/redirect">redirect</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/reduce*">reduce*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/reductions*">reductions*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/release-named-channel">release-named-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/remove*">remove*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/restart">restart</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/run-pipeline">run-pipeline</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/sample-every">sample-every</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/siphon-result">siphon-result</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/splice">splice</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/take*">take*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/take-while*">take-while*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/task">task</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait-for-message">wait-for-message</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait-for-result">wait-for-result</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait-stage">wait-stage</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/with-timeout">with-timeout</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#lamina.core.operators">lamina.core.operators</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core.operators/sample-every">sample-every</a>
    </div>
    <br />
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="namespace-name">lamina.core</span></h1>
by <span id="author">Zachary Tellman</span><br />
<br />Usage:
<pre>
(ns your-namespace
  (:require <span id="long-name">lamina.core</span>))
</pre><pre>
</pre><h2>Overview</h2>
<pre id="namespace-docstr"></pre>
<br />
<h2>Public Variables and Functions</h2>
<div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/async">async</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (async &amp; body)
</pre>
  <pre id="var-docstr">Turns standard Clojure expressions into a dataflow representation of the computation.

Any result-channel can be treated as a real value inside the async block.  The value
returned by the async block will be a result-channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/cancel-callback">cancel-callback</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (cancel-callback ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Cancels one or more callbacks.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/channel-pair">channel-pair</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (channel-pair)
       (channel-pair a b)
</pre>
  <pre id="var-docstr">Creates paired channels, where an enqueued message from one channel
can be received from the other.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/channel-seq">channel-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (channel-seq ch)
       (channel-seq ch timeout)
</pre>
  <pre id="var-docstr">Creates a non-lazy sequence which consumes all messages from the channel within the next
'timeout' milliseconds.  A timeout of 0, which is the default, will only consume messages
currently within the channel.

This call is synchronous, and will hang the thread until the timeout is reached or the channel
is drained.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/close">close</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (close ch)
</pre>
  <pre id="var-docstr">Closes the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/closed-channel">closed-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (closed-channel &amp; messages)
</pre>
  <pre id="var-docstr">Creates a channel which is already sealed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/closed?">closed?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (closed? ch)
</pre>
  <pre id="var-docstr">Returns true if no more messages can be enqueued into the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/complete">complete</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (complete result)
</pre>
  <pre id="var-docstr">Skips to the end of the inner-most pipeline, causing it to emit 'result'.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/defn-async">defn-async</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defn-async &amp; body)
</pre>
  <pre id="var-docstr">Creates an asynchronous function.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/do-stage">do-stage</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (do-stage &amp; body)
</pre>
  <pre id="var-docstr">Creates a pipeline stage that emits the same value it receives, but performs some side-effect
in between.  Useful for debug prints and logging.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/drained?">drained?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (drained? ch)
</pre>
  <pre id="var-docstr">Returns true if no more messages can be received from the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/enqueue">enqueue</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (enqueue ch &amp; messages)
</pre>
  <pre id="var-docstr">Enqueues messages into the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/enqueue-and-close">enqueue-and-close</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (enqueue-and-close ch &amp; messages)
</pre>
  <pre id="var-docstr">Enqueues the final messages into the channel, sealing it.  When this message is
received, the channel will be closed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/filter*">filter*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (filter* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume all messages from 'ch', but only emit messages
for which (f msg) is true.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/force-all">force-all</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (force-all expr)
</pre>
  <pre id="var-docstr">Forces a sequence of results.  Subsequent expressions will wait on all results being
realized, but the results can be completed in any order.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/fork">fork</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (fork ch)
       (fork n ch)
</pre>
  <pre id="var-docstr">Creates one or many exact copies of 'ch'.  Messages enqueued into the original channel
will appear in all copies, but can be consumed separately.  This allows for multiple
consumers to receive the same stream at different rates.

Any message enqueued into one channel will be enqueued into all other copies.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/lazy-channel-seq">lazy-channel-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (lazy-channel-seq ch)
       (lazy-channel-seq ch timeout)
</pre>
  <pre id="var-docstr">Creates a lazy-seq which consumes messages from the channel.  Only elements
which are realized will be consumes.

(take 1 (lazy-channel-seq ch)) will only take a single message from the channel,
and no more.  If there are no messages in the channel, execution will halt until
a message is enqueued.

'timeout' controls how long (in ms) the sequence will wait for each element.  If
the timeout is exceeded or the channel is closed, the sequence will end.  By default,
the sequence will never time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/map*">map*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (map* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume all messages from 'ch', and emit (f msg).</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/named-channel">named-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (named-channel key)
       (named-channel key creation-callback)
</pre>
  <pre id="var-docstr">Returns a unique channel for the key.  If no such channel exists,
a channel is created, and 'creation-callback' is invoked.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/on-closed">on-closed</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (on-closed ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Registers callbacks that will be triggered by the channel closing.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/on-drained">on-drained</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (on-drained ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Registers callbacks that will be triggered by the channel being drained.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/partition*">partition*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (partition* n ch)
       (partition* n step ch)
</pre>
  <pre id="var-docstr">Returns a partitioned channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/partition-all*">partition-all*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (partition-all* n ch)
       (partition-all* n step ch)
</pre>
  <pre id="var-docstr">Returns a partitioned channel, including any trailing messages that aren't evenly divisable.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/pipeline">pipeline</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (pipeline &amp; opts+stages)
</pre>
  <pre id="var-docstr">Returns a function with an arity of one.  Invoking the function will return
a pipeline channel.

Stages should either be pipelines, or functions with an arity of one.  These functions
should either return a pipeline channel, a redirect signal, or a value which will be passed
into the next stage.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/poll">poll</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (poll channel-map)
       (poll channel-map timeout)
</pre>
  <pre id="var-docstr">Allows you to consume exactly one message from multiple channels.

If the function is called with (poll {:a a, :b b}), and channel 'a' is
the first to emit a message, the function will return a constant channel
which emits [:a message].

If the poll times out, the constant channel will emit 'nil'.  If a timeout
is not specified, the poll will never time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/read-channel">read-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (read-channel ch)
       (read-channel ch timeout)
</pre>
  <pre id="var-docstr">For reading channels within pipelines.  Takes a simple channel, and returns
a result channel representing the next message from the channel.  If the timeout
elapses, the result channel will emit an error.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/read-merge">read-merge</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (read-merge read-fn merge-fn)
</pre>
  <pre id="var-docstr">For merging asynchronous reads into a pipeline.

'read-fn' is a function that takes no parameters and returns a value, which
can be a pipeline channel representing an asynchronous read.

'merge-fn' is a function which takes two parameters - the incoming value from
the pipeline and the value from read-fn - and returns a single value that
will propagate forward into the pipeline.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/receive">receive</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (receive ch a)
       (receive ch a b)
       (receive ch a b &amp; callbacks)
</pre>
  <pre id="var-docstr">Adds one or more callbacks which will receive the next message from the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/receive-in-order">receive-in-order</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (receive-in-order ch f)
</pre>
  <pre id="var-docstr">Consumes messages from a channel one at a time.  The callback will only receive the next
message once it has completed processing the previous one.  If the callback returns a result
channel, the next message will not be received until there is a result.

This is a lossy iteration over the channel.  Fork the channel if there is another consumer.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/redirect">redirect</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (redirect pipeline)
       (redirect pipeline value)
</pre>
  <pre id="var-docstr">Returns a redirect signal, which if returned by a pipeline stage will
skip all remaining stages in the current pipeline, and begin executing
the stages in 'pipeline'.  'value' describes the initial value passed into
the new pipeline, and defaults to the initial value passed into the current
pipeline.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/reduce*">reduce*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (reduce* f ch)
       (reduce* f val ch)
</pre>
  <pre id="var-docstr">Returns a result-channel which will emit the result of the reduce once the channel has been exhausted.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/reductions*">reductions*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (reductions* f ch)
       (reductions* f val ch)
</pre>
  <pre id="var-docstr">Returns a channel which contains the intermediate results of the reduce operation.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/release-named-channel">release-named-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (release-named-channel key)
</pre>
  <pre id="var-docstr">Forgets the channel associated with the key, if one exists.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/remove*">remove*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (remove* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume all messages from 'ch', but only emit messages
for which (f msg) is false.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/restart">restart</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (restart)
       (restart value)
</pre>
  <pre id="var-docstr">A special form of redirect, which simply restarts the current pipeline.  'value'
describe sthe initial value passed into the first stage of the current pipeline,
and defaults to the value that was previously passed into the first stage.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/run-pipeline">run-pipeline</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (run-pipeline initial-value &amp; opts+stages)
</pre>
  <pre id="var-docstr">Equivalent to ((pipeline opts+stages) initial-value).

Returns a pipeline future.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/sample-every">sample-every</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sample-every period ch)
</pre>
  <pre id="var-docstr">Returns a channel which will emit the last message enqueued into 'ch' every 'period'
milliseconds.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/siphon-result">siphon-result</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (siphon-result src dst)
</pre>
  <pre id="var-docstr">Siphons the result from one result-channel to another.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/splice">splice</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (splice emitter receiver)
</pre>
  <pre id="var-docstr">Splices together a message emitter and a message receiver
into a single channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/take*">take*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (take* n ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume 'n' messages from 'ch'.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/take-while*">take-while*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (take-while* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume messages from 'ch' until (f msg) is false.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/task">task</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (task &amp; body)
</pre>
  <pre id="var-docstr">A variation of 'future' that returns a result-channel instead of a synchronous
future object.

When used within (async ...), it's simply an annotation that the body should be executed
on a separate thread.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait-for-message">wait-for-message</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wait-for-message ch)
       (wait-for-message ch timeout)
</pre>
  <pre id="var-docstr">Synchronously consumes a single message from a channel.  If no message is received within the
timeout, a java.util.concurrent.TimeoutException is thrown.  By default, this function will
not time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait-for-result">wait-for-result</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wait-for-result result-channel)
       (wait-for-result result-channel timeout)
</pre>
  <pre id="var-docstr">Waits for a result-channel to emit a result.  If it succeeds, returns the result.
If there was an error, the exception is re-thrown.

If the timeout elapses, a java.util.concurrent.TimeoutException is thrown.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait-stage">wait-stage</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (wait-stage interval)
</pre>
  <pre id="var-docstr">Creates a pipeline stage that accepts a value, and emits the same value after 'interval' milliseconds.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/with-timeout">with-timeout</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (with-timeout timeout &amp; body)
</pre>
  <pre id="var-docstr">Wraps a body that returns a result-channel, and returns a new result-channel that will
emit a java.util.concurrent.TimeoutException if the inner result-channel doesn't yield
a value in 'timeout' ms.</pre>
  
</div>
<h2 id="namespace-name">lamina.core.operators</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="lamina.core.operators/sample-every">sample-every</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sample-every period ch)
</pre>
  <pre id="var-docstr">Returns a channel which will emit the last message enqueued into 'ch' every 'period'
milliseconds.</pre>
  
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">No copyright info </div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>