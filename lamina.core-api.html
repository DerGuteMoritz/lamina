<html>
  <head>
    <title>lamina.core API reference (lamina)</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <!-- TODO: are we using these (from clojure.org)? If so, add the files -->
    <script src="file/view/code_highlighter.js" type="text/javascript"></script>
    <script src="file/view/clojure.js" type="text/javascript"></script>
    <style>.menuWrapper{height: 36px;}</style>
    <!--[if lte IE 6]>
    <link rel="stylesheet" href="http://www.wikispaces.com/_/2009051601/s/internal_ie.css" type="text/css" />
    <![endif]-->
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">lamina</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <a class="wiki_link" href="index.html">Overview</a><br />
    <a class="wiki_link" href="api-index.html">API Index</a><br />
    <a class="wiki_link" href="#">Namespaces:</a>
    <ul id="left-sidebar-list">
      <li><a href="lamina.connections-api.html" class="wiki_link">lamina.connections</a></li><li><a href="lamina.core-api.html" class="wiki_link">lamina.core</a></li>
    </ul>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0">Overview</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/blocking">blocking</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/cancel-callback">cancel-callback</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/channel-pair">channel-pair</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/channel-seq">channel-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/close">close</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/closed?">closed?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/complete">complete</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/enqueue">enqueue</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/enqueue-and-close">enqueue-and-close</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/filter*">filter*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/fork">fork</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/lazy-channel-seq">lazy-channel-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/map*">map*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/named-channel">named-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/on-closed">on-closed</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/on-sealed">on-sealed</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/pipeline">pipeline</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/poll">poll</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/read-channel">read-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/read-merge">read-merge</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/receive">receive</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/receive-all">receive-all</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/receive-in-order">receive-in-order</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/reduce*">reduce*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/reductions*">reductions*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/release-named-channel">release-named-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/run-pipeline">run-pipeline</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/sealed-channel">sealed-channel</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/sealed?">sealed?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/splice">splice</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/take*">take*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/take-while*">take-while*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait-for-message">wait-for-message</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#lamina.core/wait-for-result">wait-for-result</a>
    </div>
    <br />
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="namespace-name">lamina.core</span></h1>
by <span id="author">Zachary Tellman</span><br />
<br />Usage:
<pre>
(ns your-namespace
  (:require <span id="long-name">lamina.core</span>))
</pre><pre>
</pre><h2>Overview</h2>
<pre id="namespace-docstr"></pre>
<br />
<h2>Public Variables and Functions</h2>
<div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/blocking">blocking</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (blocking f)
</pre>
  <pre id="var-docstr">Takes a synchronous function, and returns a function which will be executed asynchronously,
and whose invocation will return a pipeline channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/cancel-callback">cancel-callback</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (cancel-callback ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Cancels one or more callbacks.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/channel-pair">channel-pair</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (channel-pair)
       (channel-pair a b)
</pre>
  <pre id="var-docstr">Creates paired channels, where an enqueued message from one channel
can be received from the other.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/channel-seq">channel-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (channel-seq ch)
       (channel-seq ch timeout)
</pre>
  <pre id="var-docstr">Creates a non-lazy sequence which consumes all messages from the channel within the next
'timeout' milliseconds.  A timeout of 0, which is the default, will only consume messages
currently within the channel.

This call is synchronous, and will hang the thread until the timeout is reached or the channel
is closed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/close">close</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (close ch)
</pre>
  <pre id="var-docstr">Closes the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/closed?">closed?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (closed? ch)
</pre>
  <pre id="var-docstr">Returns true if no more messages can be received from the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/complete">complete</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (complete result)
</pre>
  <pre id="var-docstr">Short-circuits the inner-most pipeline, returning the result.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/enqueue">enqueue</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (enqueue ch &amp; messages)
</pre>
  <pre id="var-docstr">Enqueues messages into the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/enqueue-and-close">enqueue-and-close</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (enqueue-and-close ch &amp; messages)
</pre>
  <pre id="var-docstr">Enqueues the final messages into the channel, sealing it.  When this message is
received, the channel will be closed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/filter*">filter*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (filter* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume all messages from 'ch', but only emit messages
for which (f msg) is true.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/fork">fork</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (fork ch)
       (fork n ch)
</pre>
  <pre id="var-docstr">Creates one or many exact copies of 'ch'.  Messages enqueued into the original channel
will appear in all copies, but can be consumed separately.  This allows for multiple
consumers to receive the same stream at different rates.

All copies are receive-only.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/lazy-channel-seq">lazy-channel-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (lazy-channel-seq ch)
       (lazy-channel-seq ch timeout)
</pre>
  <pre id="var-docstr">Creates a lazy-seq which consumes messages from the channel.  Only elements
which are realized will be consumes.

(take 1 (lazy-channel-seq ch)) will only take a single message from the channel,
and no more.  If there are no messages in the channel, execution will halt until
a message is enqueued.

'timeout' controls how long (in ms) the sequence will wait for each element.  If
the timeout is exceeded or the channel is closed, the sequence will end.  By default,
the sequence will never time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/map*">map*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (map* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume all messages from 'ch', and emit (f msg).</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/named-channel">named-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (named-channel key)
       (named-channel key creation-callback)
</pre>
  <pre id="var-docstr">Returns a unique channel for the key.  If no such channel exists,
a channel is created, and 'creation-callback' is invoked.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/on-closed">on-closed</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (on-closed ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Registers callbacks that will be triggered by the channel closing.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/on-sealed">on-sealed</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (on-sealed ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Registers callbacks that will be triggered by the channel being sealed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/pipeline">pipeline</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (pipeline &amp; opts+stages)
</pre>
  <pre id="var-docstr">Returns a function with an arity of one.  Invoking the function will return
a pipeline channel.

Stages should either be pipelines, or functions with an arity of one.  These functions
should either return a pipeline channel, a redirect signal, or a value which will be passed
into the next stage.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/poll">poll</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (poll channel-map)
       (poll channel-map timeout)
</pre>
  <pre id="var-docstr">Allows you to consume exactly one message from multiple channels.

If the function is called with (poll {:a a, :b b}), and channel 'a' is
the first to emit a message, the function will return a constant channel
which emits [:a message].

If the poll times out, the constant channel will emit 'nil'.  If a timeout
is not specified, the poll will never time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/read-channel">read-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (read-channel ch)
       (read-channel ch timeout)
</pre>
  <pre id="var-docstr">For reading channels within pipelines.  Takes a simple channel, and returns
a pipeline channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/read-merge">read-merge</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (read-merge read-fn merge-fn)
</pre>
  <pre id="var-docstr">For merging asynchronous reads into a pipeline.

'read-fn' is a function that takes no parameters and returns a value, which
can be a pipeline channel representing an asynchronous read.

'merge-fn' is a function which takes two parameters - the incoming value from
the pipeline and the value from read-fn - and returns a single value that
will propagate forward into the pipeline.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/receive">receive</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (receive ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Adds one or more callbacks which will receive the next message from the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/receive-all">receive-all</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (receive-all ch &amp; callbacks)
</pre>
  <pre id="var-docstr">Adds one or more callbacks which will receive all messages from the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/receive-in-order">receive-in-order</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (receive-in-order ch f)
</pre>
  <pre id="var-docstr">Consumes messages from a channel one at a time.  The callback will only receive the next
message once it has completed processing the previous one.  If the callback returns a result
channel, the next message will not be received until there is a result.

This is a lossy iteration over the channel.  Fork the channel if there is another consumer.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/reduce*">reduce*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (reduce* f ch)
       (reduce* f val ch)
</pre>
  <pre id="var-docstr">Returns a constant-channel which will return the result of the reduce once the channel has been exhausted.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/reductions*">reductions*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (reductions* f ch)
       (reductions* f val ch)
</pre>
  <pre id="var-docstr">Returns a channel which contains the intermediate results of the reduce operation.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/release-named-channel">release-named-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (release-named-channel key)
</pre>
  <pre id="var-docstr">Forgets the channel associated with the key, if one exists.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/run-pipeline">run-pipeline</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (run-pipeline initial-value &amp; opts+stages)
</pre>
  <pre id="var-docstr">Equivalent to ((pipeline opts+stages) initial-value).

Returns a pipeline future.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/sealed-channel">sealed-channel</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sealed-channel &amp; messages)
</pre>
  <pre id="var-docstr">Creates a channel which is already sealed.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/sealed?">sealed?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sealed? ch)
</pre>
  <pre id="var-docstr">Returns true if no more messages can be enqueued into the channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/splice">splice</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (splice src dst)
</pre>
  <pre id="var-docstr">Splices together a message source and a message destination
into a single channel.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/take*">take*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (take* n ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume 'n' messages from 'ch'.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/take-while*">take-while*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (take-while* f ch)
</pre>
  <pre id="var-docstr">Returns a channel which will consume messages from 'ch' until (f msg) is false.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait-for-message">wait-for-message</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wait-for-message ch)
       (wait-for-message ch timeout)
</pre>
  <pre id="var-docstr">Synchronously consumes a single message from a channel.  If no message is received within the
timeout, a java.util.concurrent.TimeoutException is thrown.  By default, this function will
not time out.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="lamina.core/wait-for-result">wait-for-result</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wait-for-result result-channel)
       (wait-for-result result-channel timeout)
</pre>
  <pre id="var-docstr">Waits for a pipeline to complete.  If it succeeds, returns the result.
If there was an error, the exception is re-thrown.</pre>
  
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">No copyright info </div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>